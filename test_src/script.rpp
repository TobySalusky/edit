import std;
import rl;
import perlin; // used by `perlin_field` effect
import list;
import script_interface;

int CANVAS_WIDTH = 1200;
int CANVAS_HEIGHT = 900;

// helper for `cool_effect` effect
// List<Vec2> GenPoints() {
// 	List<Vec2> points = .();
//
// 	int pixels_per = 120;
//
// 	for (int i in 0..=(CANVAS_WIDTH/pixels_per)) {
// 		points.add(.(i*pixels_per, 0));
// 		points.add(.(i*pixels_per, CANVAS_HEIGHT));
// 	}
// 	for (int i in 0..=(CANVAS_HEIGHT/pixels_per)) {
// 		points.add(.(0, i*pixels_per));
// 		points.add(.(CANVAS_WIDTH, i*pixels_per));
// 	}
//
// 	return points;
// }
// List<Vec2> points = GenPoints();

// EFFECTS --------
// void my_fx(ElementInfo& info, float ray_density, int some_custom_var) {
// 	info.pos; info.scale; 
// }

// void cool_effect(Vec2 pos, Vec2 scale, float rotation, Color color) {
// 	Vec2 center = pos + scale.divide(2);
//
// 	for (let p in points) {
// 		d.Line(p, center, 3, Colors.Orange);
// 	}
//
// 	d.Circle(center, 11, Colors.Black);
// 	d.Circle(center, 10, color);
// }

// void perlin_field(Vec2 pos, Vec2 scale, float rotation, Color color) {
// 	float factor = 0.1;
// 	float pos_factor = 0.01;
// 	int dot_size = 120;
// 	Vec2 stride = .(CANVAS_WIDTH / dot_size, CANVAS_HEIGHT / dot_size);
//
// 	for (int col in 0..dot_size) {
// 		for (int row in 0..dot_size) {
// 			float x = pos.x * pos_factor + factor * col;
// 			float y = pos.y * pos_factor + factor * row;
// 			float z = pos.x * pos_factor - pos.y * pos_factor / 2;
//
// 			float noise = stb.perlin.turbulence_noise3(x, y, z, 2, 0.5, 6);
// 			d.Circle(stride * v2(col, row), noise * 2 + 1, ColorLerp(Colors.Red, color, noise));
// 		}
// 	}
// }

@fx_fn
void MyFx2(FxArgs& args) {
	println(t"no margs, just args");
}
CustomFnHandle __scriptgen_NewFxFn_MyFx2() {
	c:void^ ptr = MyFx2; // TODO: fn name -> void^ conversion
	// .ptr = MyFx as c:void^, // NOTE: also doesn't work :(
	return {
		:ptr,
		.custom_arg_t_name = NULL
	};
}

@fx_fn
void MyFx(FxArgs& args, MyArgs& margs) {
	// ...
	// println(t"Wow I'm being called!!!");
	// println(t"I'm even being called with args!!?? {(^args) as ulong} {(^margs) as ulong}");
	println(t"margs: {margs.tstringify()}");

	
}
CustomFnHandle __scriptgen_NewFxFn_MyFx() {
	c:void^ ptr = MyFx; // TODO: fn name -> void^ conversion
	// .ptr = MyFx as c:void^, // NOTE: also doesn't work :(
	return {
		:ptr,
		.custom_arg_t_name = "MyArgs"
	};
}

@fx_args
struct MyArgs {
	float f;
	Vec2 v;

	char^ tstringify() {
		return t"MyArgs({f=}, v=[{v.x}, {v.y}])";
	}
}

CustomStructHandle __scriptgen_NewFxArgs_MyArgs() {
	List<CustomStructMemberHandle> members = .();

	// ---
	MyArgs^ args = c:calloc(1, sizeof<MyArgs>);
	args#f = -3;
	args#v = v2(1, 0);

	members.add({
		.name = "f",
		.ptr = ^args#f,
		.t = CustomStructMemberTypeFloat{},
	});

	members.add({
		.name = "v.x",
		.ptr = ^args#v.x,
		.t = CustomStructMemberTypeFloat{},
	});
	members.add({
		.name = "v.y",
		.ptr = ^args#v.y,
		.t = CustomStructMemberTypeFloat{},
	});
	// ---

	return {
		:members,
		.ptr = args
	};
}
