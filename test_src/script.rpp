import std;
import rl;
import perlin; // used by `perlin_field` effect
import list;
import script_interface;

int CANVAS_WIDTH = 1200;
int CANVAS_HEIGHT = 900;

// helper for `cool_effect` effect
List<Vec2> GenPoints(int pixels_per) {
	List<Vec2> points = .();

	for (int i in 0..=(CANVAS_WIDTH/pixels_per)) {
		points.add(.(i*pixels_per, 0));
		points.add(.(i*pixels_per, CANVAS_HEIGHT));
	}
	for (int i in 0..=(CANVAS_HEIGHT/pixels_per)) {
		points.add(.(0, i*pixels_per));
		points.add(.(CANVAS_WIDTH, i*pixels_per));
	}

	return points;
}
// List<Vec2> points = GenPoints();

// EFFECTS --------
@fx_args
struct CoolArgs {
	float pixels_per;
}

@fx_fn
void cool_effect(FxArgs& args, CoolArgs& margs) {
	Vec2 center = args.pos + args.scale.divide(2);

	let points = GenPoints(margs.pixels_per as int);
	defer points.delete();
	for (let p in points) {
		d.Line(p, center, 3, Colors.Orange);
	}

	d.Circle(center, 11, Colors.Black);
	d.Circle(center, 10, args.color);
}

@fx_args
struct PerlinArgs {
	float dot_size;
}

@fx_fn
void perlin_field(FxArgs& args, PerlinArgs& margs) {
	float factor = 0.1;
	float pos_factor = 0.01;
	int dot_size = margs.dot_size as int;
	Vec2 stride = .(CANVAS_WIDTH / dot_size, CANVAS_HEIGHT / dot_size);

	for (int col in 0..dot_size) {
		for (int row in 0..dot_size) {
			float x = args.pos.x * pos_factor + factor * col;
			float y = args.pos.y * pos_factor + factor * row;
			float z = args.pos.x * pos_factor - args.pos.y * pos_factor / 2;

			float noise = stb.perlin.turbulence_noise3(x, y, z, 2, 0.5, 6);
			d.Circle(stride * v2(col, row), noise * 2 + 1, ColorLerp(Colors.Red, args.color, noise));
		}
	}
}

@fx_fn
void MyFx2(FxArgs& args) {
	// println(t"no margs, just args");
}
// CustomFnHandle __scriptgen_NewFxFn_MyFx2() {
// 	c:void^ ptr = MyFx2; // TODO: fn name -> void^ conversion
// 	// .ptr = MyFx as c:void^, // NOTE: also doesn't work :(
// 	return {
// 		:ptr,
// 		.custom_arg_t_name = NULL
// 	};
// }

// CustomFnHandle __scriptgen_NewFxFn_MyFx() {
// 	c:void^ ptr = MyFx; // TODO: fn name -> void^ conversion
// 	// .ptr = MyFx as c:void^, // NOTE: also doesn't work :(
// 	return {
// 		:ptr,
// 		.custom_arg_t_name = "MyArgs"
// 	};
// }

@fx_args
struct MyArgs {
	float bar1;
	float bar2;
	float bar3;

	Vec2 my_scalar;
}

// CustomStructHandle __scriptgen_NewFxArgs_MyArgs() {
// 	List<CustomStructMemberHandle> members = .();
//
// 	// ---
// 	MyArgs^ args = c:calloc(1, sizeof<MyArgs>);
// 	args#f = -3;
// 	args#v = v2(1, 0);
//
// 	members.add({
// 		.name = "f",
// 		.ptr = ^args#f,
// 		.t = CustomStructMemberTypeFloat{},
// 	});
//
// 	members.add({
// 		.name = "v.x",
// 		.ptr = ^args#v.x,
// 		.t = CustomStructMemberTypeFloat{},
// 	});
// 	members.add({
// 		.name = "v.y",
// 		.ptr = ^args#v.y,
// 		.t = CustomStructMemberTypeFloat{},
// 	});
// 	// ---
//
// 	return {
// 		:members,
// 		.ptr = args
// 	};
// }

void Bar(float h, int col, Color color, Vec2 scalar) {
	Vec2 p = v2(col as float * (150.0 + scalar.x), 800.0 - h);
	Vec2 dims = v2(140, h);
	d.Rect(p, dims * (scalar.divide(300) + v2(1, 1)), color);
}

@fx_fn
void MyFx(FxArgs& args, MyArgs& margs) {
	Bar(margs.bar1, 1, Colors.Red, margs.my_scalar);
	Bar(margs.bar2, 2, Colors.Orange, margs.my_scalar);
	Bar(margs.bar3, 3, Colors.Yellow, margs.my_scalar);
}
