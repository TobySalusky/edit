import std;
import rl;
import perlin; // used by `perlin_field` effect
import data;

int CANVAS_WIDTH = 1200;
int CANVAS_HEIGHT = 900;

// helper for `cool_effect` effect
List<Vec2> GenPoints() {
	List<Vec2> points = .();

	int pixels_per = 120;

	for (int i in 0..=(CANVAS_WIDTH/pixels_per)) {
		points.add(.(i*pixels_per, 0));
		points.add(.(i*pixels_per, CANVAS_HEIGHT));
	}
	for (int i in 0..=(CANVAS_HEIGHT/pixels_per)) {
		points.add(.(0, i*pixels_per));
		points.add(.(CANVAS_WIDTH, i*pixels_per));
	}

	return points;
}
List<Vec2> points = GenPoints();

// EFFECTS --------
// void my_fx(ElementInfo& info, float ray_density, int some_custom_var) {
// 	info.pos; info.scale; 
// }

void cool_effect(Vec2 pos, Vec2 scale, float rotation, Color color) {
	Vec2 center = pos + scale.divide(2);

	for (let p in points) {
		d.Line(p, center, 3, Colors.Orange);
	}

	d.Circle(center, 11, Colors.Black);
	d.Circle(center, 10, color);
}

void perlin_field(Vec2 pos, Vec2 scale, float rotation, Color color) {
	float factor = 0.1;
	float pos_factor = 0.01;
	int dot_size = 120;
	Vec2 stride = .(CANVAS_WIDTH / dot_size, CANVAS_HEIGHT / dot_size);

	for (int col in 0..dot_size) {
		for (int row in 0..dot_size) {
			float x = pos.x * pos_factor + factor * col;
			float y = pos.y * pos_factor + factor * row;
			float z = pos.x * pos_factor - pos.y * pos_factor / 2;

			float noise = stb.perlin.turbulence_noise3(x, y, z, 2, 0.5, 6);
			d.Circle(stride * v2(col, row), noise * 2 + 1, ColorLerp(Colors.Red, color, noise));
		}
	}
}

void bar_chart(Vec2 pos, Vec2 scale, float rotation, Color color, Data^ data) {
	if (data == NULL) {
		return;
	}

	List<char^> bar_labels = data#headers;
	int bar_count = bar_labels.size;
	SpreadSheetRow& bar_heights = data#data.get(0);

	float max_bar_value = 0.0;
    float spacing = 5.0;
    float total_spacing = spacing * (bar_count - 1);
    float bar_width = (scale.x - total_spacing) / bar_count;
    float bar_height = scale.y;

	// Find max bar value
	for (int i in 0..bar_count) {
		float bar_value = c:atof(bar_heights.get(bar_labels.get(i))) as float;
		if (bar_value > max_bar_value) {
			max_bar_value = bar_value;
		}
	}

	// Draw bars
    for (int i in 0..bar_count) {
		float bar_x = spacing + pos.x as float + i as float * (bar_width + spacing);
		float bar_value = c:atof(bar_heights.get(bar_labels.get(i))) as float;
		float current_bar_height = bar_value / max_bar_value * bar_height;
        d.Rect(.(bar_x, pos.y + scale.y - current_bar_height), .(bar_width - 10, current_bar_height), color);
    }

    // Draw x-axis
    d.Line(v2(pos.x, pos.y + scale.y), .(pos.x + scale.x, pos.y + scale.y), 2, Colors.White);
    
	// Draw y-axis
    d.Line(pos, .(pos.x, pos.y + scale.y), 2, Colors.White);

	// Draw x-axis ticks and labels
	for (int i in 0..bar_count) {
		char^ bar_label = bar_labels.get(i);
		int text_width = c:MeasureText(bar_label, 20);
		
		// Draw tick and text label
		float tick_x = pos.x as float + i as float * (bar_width + spacing) + bar_width / 2;
		d.Line(.(tick_x, pos.y + scale.y), .(tick_x, pos.y + 10 + scale.y), 2, Colors.White);
		d.Text(bar_label, tick_x as int - (text_width / 2) as int, pos.y as int + 15 + scale.y as int, 20, Colors.White);
	}

	// Draw y-axis ticks and labels
	float curr_y_label = 0.0;
	for (int i in 0..bar_count) {
		float curr_y_label = max_bar_value / bar_count * (i + 1);
		char^ curr_y_label_str = c:malloc(6);
		c:gcvt(curr_y_label, 3, curr_y_label_str);
		int text_width = c:MeasureText(curr_y_label_str, 20);
		defer c:free(curr_y_label_str);

		// Draw tick and text label
		int tick_y = pos.y as int + scale.y as int - (i + 1) * (bar_height as int / bar_count as int);
		d.Line(.(pos.x - 10, tick_y), .(pos.x, tick_y), 2, Colors.White);
		d.Text(curr_y_label_str, pos.x as int - text_width as int - 15, tick_y as int - 5, 20, Colors.White);
	}
}