import std;
import rl;
import perlin; // used by `perlin_field` effect

int CANVAS_WIDTH = 1200;
int CANVAS_HEIGHT = 900;

// helper for `cool_effect` effect
List<Vec2> GenPoints() {
	List<Vec2> points = .();

	int pixels_per = 120;

	for (int i in 0..=(CANVAS_WIDTH/pixels_per)) {
		points.add(.(i*pixels_per, 0));
		points.add(.(i*pixels_per, CANVAS_HEIGHT));
	}
	for (int i in 0..=(CANVAS_HEIGHT/pixels_per)) {
		points.add(.(0, i*pixels_per));
		points.add(.(CANVAS_WIDTH, i*pixels_per));
	}

	return points;
}
List<Vec2> points = GenPoints();

// EFFECTS --------
void cool_effect(Vec2 pos, Vec2 scale, float rotation, Color color) {
	Vec2 center = pos + scale.divide(2);

	for (let p in points) {
		d.Line(p, center, 3, Colors.Orange);
	}

	d.Circle(center, 11, Colors.Black);
	d.Circle(center, 10, color);
}

void perlin_field(Vec2 pos, Vec2 scale, float rotation, Color color) {
	float factor = 0.1;
	float pos_factor = 0.01;
	int dot_size = 120;
	Vec2 stride = .(CANVAS_WIDTH / dot_size, CANVAS_HEIGHT / dot_size);

	for (int col in 0..dot_size) {
		for (int row in 0..dot_size) {
			float x = pos.x * pos_factor + factor * col;
			float y = pos.y * pos_factor + factor * row;
			float z = pos.x * pos_factor - pos.y * pos_factor / 2;

			float noise = stb.perlin.turbulence_noise3(x, y, z, 2, 0.5, 6);
			d.Circle(stride * v2(col, row), noise * 2 + 1, ColorLerp(Colors.Red, color, noise));
		}
	}
}
