import rl;
import theming;
import timer;
import thread;
import element;
import ui_elements;
import maths;

import std;
import map;

import dylib;
import code_manager;

c:import "rlgl.h";
c:import "tinyfiledialogs.h";

int window_width = 1200;
int window_height = 900;
Vec2 window_dimens = v2(window_width, window_height);

RenderTexture canvas;

Texture eye_open_icon;
Texture eye_closed_icon;
Texture warning_icon;
Texture image_icon;

List<Image> images;
int max_images;

int frame_rate = 60;

int current_frame = 0;
float current_time = 0;
float max_time = 5;
int max_frames = (max_time * frame_rate) as int;
float time_per_frame = 1.0 / frame_rate;


int MODE_RUNNING = 0;
int MODE_EXPORTING = 1;
int MODE_PAUSED = 2;

int mode = MODE_RUNNING;

bool is_running() -> mode == MODE_RUNNING;
bool is_exporting() -> mode == MODE_EXPORTING;
bool is_paused() -> mode == MODE_PAUSED;

bool ui_hidden = false;

struct ExportState {
	int total_frames;
	int frames_rendered;
	int frames_written;

	bool is_ffmpegging;
	float start_ffmpeg_time;
}

ExportState make_export_state() -> {
	.total_frames = max_frames,
	.frames_rendered = 0,
	.frames_written = 0,
	.is_ffmpegging = false,
	.start_ffmpeg_time = 0
};

ExportState export_state;

// stateful elements (hardcoded, currently)
List<Element> elements = List<Element>();

int selected_elem_i = 0;

void ExportFrameThread(void^ arg) {
	int^ i_arg = arg;
	int i = *i_arg;
	free(arg);

	while (images.size <= i) { }
	Image img = images.get(i);
	c:ImageFlipVertical(^img); // TODO: flip vertical
	char^ name = f"out/frames/{i %d05}.png"; // t"" not thread safe!
	defer free(name);
	img.ExportTo(name);
	img.delete();
	export_state.frames_written++;
}

// List<TextInput> temp_inputs = .();

struct RepeatingTimer {
	float max;
	float t;

	construct(float max_t) -> { .max = max_t, .t = max_t };
	bool DidRepeatWhileUpdating() {
		t = t - rl.GetFrameTime(); // TODO: deltaTime?
		defer {
			if (t <= 0) { t = max; }
		}

		return t <= 0;
	}
}

RepeatingTimer check_code_timer = .(0.25);

void debug_print_env_config() {
	if (is_dvorak) {
		println("Setting keyboard to Dvorak (via env var)");
	}
}

Texture LoadIcon(char^ path) {
	return c:LoadTextureFromFile(path);
}

char^ OpenFileDialog(char^ title, char^ filter) {
	char^^ filters = malloc(sizeof<char^> * 3);
	filters[0] = "*.png";
	filters[1] = "*.jpg";
	filters[2] = "*.gif";
	defer free(filters);

	c:c:`char const* const* c_filters = (char const* const*) filters;`;

    char^ filePath = c:tinyfd_openFileDialog(
        "Select an image file",
        "",
        3,
        c:c_filters,
        "image files",
        0
    );
    return (filePath != NULL) ? filePath | "";
}

int main() {
	debug_print_env_config();

	code_man.Load();
	defer code_man.Unload();

	// TODO: println(t"{test.get("apple")}"); (quote properly when inserting into talloc!!)

	rl.SetTraceLogLevel(c:LOG_WARNING ~| c:LOG_ERROR);  // Log flags? -- comment out to see if I/O or shader stuff is working!
	rl.SetConfigFlags(c:FLAG_MSAA_4X_HINT);      // Enable Multi Sampling Anti Aliasing 4x (if available)

	// Window init and close
	window.Init(window_width, window_height, "zZ-edit");
	defer window.Close();

	// Audio init and close
	c:InitAudioDevice();
	defer c:CloseAudioDevice();
	c:Sound fxMP3 = c:LoadSound("assets/echo.mp3");
	defer c:UnloadSound(fxMP3);

	canvas = make_render_texture(1200, 900);

	eye_open_icon = LoadIcon(t"assets/eye_open.png");
	eye_closed_icon = LoadIcon(t"assets/eye_closed.png");
	warning_icon = LoadIcon(t"assets/warning.png");
	image_icon = LoadIcon(t"assets/image.png");

	images = List<Image>();
	images.reserve(max_frames);

	elements.add(make_interesting_element());
	//elements.add(make_cool_fn_element());
	//elements.add(make_perlin_element());
	//elements.add(make_custom_effect_element("missing_fn"));

	selected_elem_i = 0;

	// temp_inputs.add(TextInput.make("a"));
	// temp_inputs.add(TextInput.make("what"));
	// temp_inputs.add(TextInput.make(""));
	// for (let p in temp_inputs.pairs()) {
	// 	p.value.Layout(v2(10, 100 + 30 * p.key), 200);
	// }

	rl.SetTargetFPS(60);
	while (!window.ShouldClose()) {
		if (c:IsKeyPressed(c:KEY_SPACE)) {
			c:PlaySound(fxMP3);
		}

		// File drop listener
		if (c:IsFileDropped()) {
			OnFileDropped();
		}

		d.Begin();
		GameTick();
		d.End();
		tfree(); // not thread safe (don't use temp-alloc from other threads!) ----------
    }

    return 0;
}

bool look_at_controls = false;
bool show_add_element_options = false;

int panel_width = 160;
void LeftPanelUI() {
	d.Rect(v2(0, 0), v2(panel_width, window_height), theme.panel);
	d.Rect(v2(panel_width, 0), v2(1, window_height), theme.panel_border);

	// Elements List
	Vec2 btn_dimens = v2(panel_width - 20, 40);
	for (int i = 0; i != elements.size; i++;) {
		Vec2 tl = v2(10, 10 + 50 * i);
		Element& elem = elements.get(i);

		bool has_err = elem.err_msg != NULL;
		bool hovering = mouse.GetPos().Between(tl, tl + btn_dimens);
		bool hit_button = ButtonForceHover(tl, btn_dimens, elements.get(i).name, elements.get(i).Hovered(), 
							has_err ? theme.button_err | theme.button);
		bool hit_visibility = ButtonForceHover(tl + v2(btn_dimens.x - 20, 0), v2(20, 40), "", false, Colors.Gray);

		if (hit_visibility) {
			println(t"[DEBUG]: Toggled visibility for Element {i}");
			elem.visible = !elem.visible;
		} else if (hit_button) {
			println(t"[DEBUG]: Elem {i} selected");
			selected_elem_i = i;
		}

		if (elem.visible) {
			d.TextureAtSizeV(eye_open_icon, tl + v2(btn_dimens.x - 18, 12), v2(16, 16));
		}

		if (selected_elem_i == i) {
			d.RectOutline(tl, btn_dimens, theme.active);
		}

		if (has_err) {
			d.TextureAtSizeV(warning_icon, tl + v2(8, 12), v2(16, 16));

			if (hovering) {
				Vec2 options_tl = mouse.GetPos() + v2(0, 10);
				Vec2 options_dims = c:MeasureTextEx(c:GetFontDefault(), elem.err_msg, 16, 1);
				d.RectR(Rectangle.FromV(options_tl, options_dims).PadOut(6), theme.button);
				d.Text(elem.err_msg, options_tl.x as.., options_tl.y as.., 16, Colors.White);
				
				// d.Rect();
			}
		}
	}

	// for (let& input in temp_inputs) { // TODO: gd doesn't work on refs!
	// 	input.Do();
	// }

	if (show_add_element_options) {
		Vec2 options_tl = v2(10, window_height - 120);
		Vec2 options_dims = v2(panel_width - 20, 50);
		d.RectR(Rectangle.FromV(options_tl, options_dims).PadOut(6), theme.button);

		// Add media fil
		Vec2 icon_dimens = v2((panel_width - 40) / 2, 40);
		Vec2 icon_tl = options_tl + v2(5, 5);
		if (Button(icon_tl, icon_dimens, "")) {
			char^ file_path = OpenFileDialog("Select an image", "Image Files\0*.png;*.jpg;*.jpeg;*.bmp;*.tga;*.gif;*.psd;*.hdr;*.pic;*.ppm;*.pgm\0All Files\0*.*\0");
			if (file_path != NULL) {
				Image img = c:LoadImage(file_path);
				elements.add(make_image_element(file_path) with {
					scale = v2(img.width, img.height)
				});
				selected_elem_i = elements.size - 1;
				show_add_element_options = false;
			}
		}
		d.TextureAtSizeV(image_icon, icon_tl, icon_dimens);

		// Add arbitrary element (Temporary)
		Vec2 plus_tl = options_tl + v2((panel_width - 10) / 2, 5);
		if (Button(plus_tl, v2((panel_width - 40) / 2, 40), "+")) {
			elements.add(make_element());
			selected_elem_i = elements.size - 1;
		}
	}
	
	// Add Element Button
	Vec2 tl = v2(10, window_height - 50);
	if (Button(tl, btn_dimens, "+")) {
		show_add_element_options = true;
	} else if (mouse.LeftClickPressed()) {
		show_add_element_options = false;
	}

}


bool timeline_dragging = false;
void KeyframeTimelineUI() {
	int width = window_width - panel_width;
	int height = 150;
	Vec2 tl = v2(panel_width + 1, window_height - height);
	Vec2 dimens = v2(width, height);

	d.Rect(tl, dimens, theme.panel);
	d.Rect(tl, v2(dimens.x, 1), theme.panel_border);

	d.Rect(tl + v2(dimens.x * current_time / max_time, 0), v2(1, dimens.y), theme.active);

	int i = 0;

	let selected_elem = elements.get(selected_elem_i);

	int kl_height = height / 5;
	Vec2 kl_dimens = v2(dimens.x, kl_height);
	selected_elem.kl_pos_x.UI(tl + v2(0, i * kl_height), kl_dimens, max_time); i++;
	selected_elem.kl_pos_y.UI(tl + v2(0, i * kl_height), kl_dimens, max_time); i++;
	selected_elem.kl_scale.UI(tl + v2(0, i * kl_height), kl_dimens, max_time); i++;
	selected_elem.kl_rotation.UI(tl + v2(0, i * kl_height), kl_dimens, max_time); i++;
	selected_elem.kl_opacity.UI(tl + v2(0, i * kl_height), kl_dimens, max_time); i++;


	if (mouse.LeftClickPressed() && mouse.GetPos().InV(tl, dimens)) {
		timeline_dragging = true;
	}

	if (mouse.LeftClickDown() && timeline_dragging) {
		float new_time = (mouse.GetPos().x - tl.x) / dimens.x * max_time;
		if (new_time <= 0) { new_time = 0; }
		if (new_time >= max_time) { new_time = max_time; }
		SetTime(new_time); // TODO: add snap-to-frame-set-time
		SetFrame(current_frame);
	}

	if (!mouse.LeftClickDown()) {
		timeline_dragging = false;
	}
}

void SetFrame(int frame) {
	current_time = time_per_frame * frame;
	current_frame = frame;
	UpdateState();
}

void SetTime(float new_time) {
	current_time = new_time;
	current_frame = (current_time / time_per_frame) as int;
	UpdateState();
}

void UpdateState() {
	for (let& elem in elements) {
		elem.UpdateState(current_time);
	}
}

void DrawFrameToCanvas() {
	canvas.Begin();
	d.ClearBackground(theme.bg);
	for (let& elem in elements) {
		if (elem.visible) {
			elem.Draw();
		}
	}

	canvas.End();
}

void ExportVideoThread() {
	ExportVideo(frame_rate, "out/frames", "out/capture");

	mode = MODE_PAUSED;
	SetFrame(0);
}

void DrawProgressBar(Vec2 tl, Vec2 dimens, Color bg, Color fg, float amount) {
	d.Rect(tl, dimens, bg);
	d.Rect(tl, dimens * v2(amount, 1), fg);
}

void DrawExportProgressOverlay() {
	Color shadow = hex("00000077");
	d.Rect(v2(0, 0), window_dimens, shadow);

	float width = 0.5 * window_width;
	float height = 20 * 5 + 2 * 10;
	Vec2 tl = window_dimens * v2(0.25, 0.5) - v2(0, height / 2);
	Vec2 dimens = v2(width, height);
	d.Rect(tl - v2(4, -1), dimens + v2(8, 3), hex("00000033"));
	d.Rect(tl - v2(1, 1), dimens + v2(2, 2), Colors.Black);
	d.Rect(tl, dimens, theme.panel);

	Color progress_bg = hex("262626"); // gray
	Color progress_fg = hex("afc7af"); // green

	Vec2 pbar_tl = v2(tl.x + 20, tl.y + 20);
	Vec2 pbar_dimens = v2(width - 40, 20);

	DrawProgressBar(pbar_tl, pbar_dimens, progress_bg, progress_fg, (export_state.frames_rendered) as float / export_state.total_frames);

	pbar_tl.y = pbar_tl.y + 30;
	DrawProgressBar(pbar_tl, pbar_dimens, progress_bg, progress_fg, (export_state.frames_written) as float / export_state.total_frames);

	pbar_tl.y = pbar_tl.y + 30;
	Color ffmpeg_load_pulse_color = 
		export_state.is_ffmpegging
			? ColorLerp(progress_bg, progress_fg, Sin01((rl.GetTime() - export_state.start_ffmpeg_time) * 5) * 0.7)
			| progress_bg;
	d.Rect(pbar_tl, pbar_dimens, ffmpeg_load_pulse_color);
}

bool is_dvorak = c:getenv("SILLY_DVORAK_USER") != NULL;
struct HotKey {
	int key_code;
	// TODO: modifiers

	bool IsPressed() -> key.IsPressed(key_code);

	static Self DvoKey(int keycode_qwerty, int keycode_dvorak) -> {
		.key_code = is_dvorak ? keycode_dvorak | keycode_qwerty 
	};
	static Self Key(int keycode) -> Self.DvoKey(keycode, keycode);
}

struct HotKeys {
	// :hotkey

	static HotKey PlayPause = HotKey.Key(KEY.SPACE);

	static HotKey ExportMovie = HotKey.DvoKey(KEY.E, KEY.D);

	// key as in keyframe
	static HotKey KeyAtCurrentPosition  = HotKey.DvoKey(KEY.K, KEY.V);
	static HotKey Alternative_KeyAtCurrentPosition  = HotKey.DvoKey(KEY.A, KEY.A);

	static HotKey ToggleHideUIFullscreenPlayback  = HotKey.DvoKey(KEY.H, KEY.J);

	static HotKey QuickCut = HotKey.DvoKey(KEY.X, KEY.B); // contextual delete? like blender? // AT LEAST: remove Keys at current pos?

	// :hotkey:temp
	static HotKey Temp_ClearTimeline = HotKey.DvoKey(KEY.C, KEY.I);
	static HotKey Temp_DeleteElement = HotKey.DvoKey(KEY.B, KEY.N);
	static HotKey Temp_ReloadCode = HotKey.DvoKey(KEY.R, KEY.O); // TODO: make this do something else -- since we reload?

	static HotKey Temp_AddElementCircle = HotKey.DvoKey(KEY.O, KEY.S);
	static HotKey Temp_AddElementCool = HotKey.DvoKey(KEY.N, KEY.L);
}

bool init = false;
void GameTick() {
	if (check_code_timer.DidRepeatWhileUpdating()) {
		code_man.CheckModifiedTimeAndReloadIfNecessary();
	}

	d.ClearBackground(theme.bg);

	if (HotKeys.PlayPause.IsPressed()) {
		if (is_running()) {
			mode = MODE_PAUSED;
			SetFrame(current_frame);
		} else if (is_paused()) {
			mode = MODE_RUNNING;
		}
	}

	// export movie
	if (HotKeys.ExportMovie.IsPressed()) { // NOTE: E (export)
		mode = MODE_EXPORTING;
		export_state = make_export_state();
		SetFrame(0);

		io.mkdir("out/frames");
	}

	if (HotKeys.ToggleHideUIFullscreenPlayback.IsPressed()) {
		ui_hidden = !ui_hidden;
	}

	if (elements.size > 1 && HotKeys.Temp_DeleteElement.IsPressed()) {
		elements.remove_at(selected_elem_i);
		if (selected_elem_i == elements.size) { selected_elem_i--; }
	}

	if (HotKeys.Temp_ClearTimeline.IsPressed()) {
		elements.get(selected_elem_i).ClearTimelinesCompletely();
	}

	// if (HotKeys.Temp_ReloadCode.IsPressed()) {
	// 	code_man.Reload();
	// }

	if (HotKeys.Temp_AddElementCool.IsPressed()) {
		elements.add(make_cool_fn_element());
	}

	if (HotKeys.Temp_AddElementCircle.IsPressed()) {
		elements.add(make_element());
	}

	// :hotkey:use:global

	// if (!is_paused()) {
	UpdateState();
	// }

	DrawFrameToCanvas();

	if (is_running()) {
		float new_time = current_time + rl.GetFrameTime();
		if (new_time > max_time) { new_time = 0; }
		SetTime(new_time);
	} else if (is_exporting()) {
		if (images.size < max_frames) {
			Image img = c:LoadImageFromTexture(canvas.texture);
			images.add(img);
			export_state.frames_rendered++;
			int^ ip = malloc(sizeof<int>);
			*ip = images.size - 1;
			go_with(ExportFrameThread, ip);
			SetFrame(current_frame + 1);
		}
		if (!export_state.is_ffmpegging && export_state.frames_written == export_state.total_frames) {
			export_state.is_ffmpegging = true;
			export_state.start_ffmpeg_time = c:GetTime();
			go(ExportVideoThread);
		}
	}

	d.Texture(canvas, Vec2_zero);

	if (!is_exporting()) {
		if (mouse.LeftClickPressed()) {
			for (int i = elements.size - 1; i >= 0; i--;) {
				if (elements.get(i).Hovered()) {
					selected_elem_i = i;
					break;
				}
			}
		}

		elements.get(selected_elem_i).DrawGizmos();

		if (HotKeys.KeyAtCurrentPosition.IsPressed() || HotKeys.Alternative_KeyAtCurrentPosition.IsPressed()) { // NOTE: K (keyframe)
			elements.get(selected_elem_i).kl_pos_x.Insert({
				.time = current_time,
				.value = mouse.GetPos().x
			});
			elements.get(selected_elem_i).kl_pos_y.Insert({
				.time = current_time,
				.value = mouse.GetPos().y
			});
		}
	}

	if (!ui_hidden) {
		LeftPanelUI();
		KeyframeTimelineUI();
	}

	if (is_exporting()) {
		DrawExportProgressOverlay();
	}
}

void ExportVideo(int framerate, char^ folder_path, char^ output_file_name_no_path) {
	char^ video_name = t"{output_file_name_no_path}.mp4";
	system(f"ffmpeg -y -framerate {framerate} -pattern_type glob -i '{folder_path}/*.png' -c:v libx264 -pix_fmt yuv420p {video_name}");
}

void OnFileDropped() {
	FilePathList dropped_file_path_list = c:LoadDroppedFiles();
	defer c:UnloadDroppedFiles(dropped_file_path_list);
	char^ first_img_path = strdup(dropped_file_path_list.paths[0]);
	Image img = c:LoadImage(first_img_path);
	elements.add(make_image_element(first_img_path) with {
		pos = mouse.GetPos(),
		scale = v2(img.width, img.height)
	});
	selected_elem_i = elements.size - 1;
}