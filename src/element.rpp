import rl;
import keyframing;
import maths;
import theming;
import std;
import code_manager;
import script_interface;
import ui_elements;
import data;

interface ElementImpl {
	void Draw(Element^ e);

	char^ ImplTypeStr();

	List<CustomLayer>^ CustomLayers();
}
struct RectElement : ElementImpl {
	void Draw(Element^ e) {
		d.RectRot(e#pos, e#scale, e#rotation, e#color);
	}

	char^ ImplTypeStr() -> "rect";
	List<CustomLayer>^ CustomLayers() -> NULL;

	static Self^ Make() -> malloc(sizeof<Self>);
}

struct CircleElement : ElementImpl {
	void Draw(Element^ e) {
		d.Circle(e#pos + e#scale.scale(0.5), e#scale.x / 2, e#color); // TODO: allow ellipse
	}

	char^ ImplTypeStr() -> "circle";
	List<CustomLayer>^ CustomLayers() -> NULL;

	static Self^ Make() -> malloc(sizeof<Self>);
}

struct ImageCache {
	static StrMap<Texture> cache;

	static Texture Get(char^ file_path) {
		if (cache.has(file_path)) {
			return cache.get(file_path);
		}
		Texture tex = LoadTextureFromFile(file_path);
		cache.put(file_path, tex);
		return tex;
	}
	
	static void Unload() {
		for (let pair in cache) {
			pair.value.delete();
		}
	}
}

struct ImageElement : ElementImpl {
	char^ file_path;
	
	void Draw(Element^ e) {
		d.TextureAtSize(ImageCache.Get(file_path), e#pos.x, e#pos.y, e#scale.x, e#scale.y);
	}
	char^ ImplTypeStr() -> "img";
	List<CustomLayer>^ CustomLayers() -> NULL;

	static Self^ Make(char^ file_path) -> Box<Self>.Make({ :file_path });
}

c:`typedef CustomFnHandle (*CustomPureFnGetter)(void);`;
c:`typedef CustomStructHandle (*CustomArgsNewFn)(void);`;
c:`typedef void (*CustomPureFnWithoutCustomParams)(FxArgs*);`;
c:`typedef void (*CustomPureFnWithCustomParams)(FxArgs*, void*);`;

struct CustomLayerFloat {
	float^ value;
	KeyframeLayer kl_value;
}

struct CustomLayerList {
	List<CustomLayer> layers;
	List<float>^ fs;

	void AddFloatLayer() {
		fs#add(0); // TODO: check whether resized
		layers.add({
			.name = f"[{layers.size}]",
			.deleted_member = false,
			.kind = CustomLayerFloat{
				.value = NULL, // NOTE: malloc float???
				.kl_value = .()
			}
		});

		if (layers.size != fs#size) {
			assert(layers.size == fs#size, "layers.size != fs#size   !!!");
		}

		// set to float list internals!
		for (int i in 0..layers.size) {
			(layers.get(i).kind as CustomLayerFloat).value = ^fs#get(i);
		}
	}

	void UI(Vec2 global_tl, Vec2 dimens, float max_elem_time, float curr_local_time, char^ name, int& incr) {
		int i = incr;
		let tl = global_tl + v2(0, dimens.y * i);

		d.Text(name, (tl.x - 90) as.., tl.y as.., 16, Colors.White);
		d.Text("[]", (tl.x - 90 + c:MeasureText(name, 16) + 2) as.., tl.y as.., 16, Colors.SkyBlue);

		d.Rect(tl + v2(0, dimens.y), v2(dimens.x, 1), theme.panel_border);

		if (Button(tl, dimens, "+")) {
			AddFloatLayer();
		}
	}
}

choice CustomLayerKind {
	CustomLayerFloat,
	CustomLayerList,
}

struct CustomLayer {
	char^ name;
	CustomLayerKind kind;

	void UpdateState(float lt) {
		switch (kind) {
			CustomLayerFloat it -> {
				it.kl_value.SetFloat(it.value, lt);
			},
			CustomLayerList it -> {
				for (let& layer in it.layers) {
					layer.UpdateState(lt);
				}
			}
		}
	}

	void UI(Vec2 global_tl, Vec2 dimens, float max_elem_time, float curr_local_time, char^ name, int& incr) {
		int i = incr;
		let tl = global_tl + v2(0, dimens.y * i);

		switch (kind) {
			CustomLayerFloat it -> {
				let& em = kind as CustomLayerFloat;
				em.kl_value.UI(global_tl, dimens, max_elem_time, curr_local_time, name, incr);
				incr++;
			},
			CustomLayerList it -> { // it is NOT ref!!??
				let& em = kind as CustomLayerList;
				em.UI(global_tl, dimens, max_elem_time, curr_local_time, name, incr);
				incr++;
				for (let& layer in em.layers) {
					layer.UI(global_tl, dimens, max_elem_time, curr_local_time, layer.name, incr);
				}
			}
		}

	}

	bool deleted_member; // true when this used to be a named member, but has since been removed/renamed
}

struct CustomPureFnElement : ElementImpl {
	char^ fn_name;
	List<CustomLayer> custom_float_layers;
	Opt<CustomStructHandle> custom_args_handle;

	void Draw(Element^ e) {
		let fn_getter_res = code_man.GetFn(t"__scriptgen_NewFxFn_{fn_name}"); // creates handle

		switch (fn_getter_res) {
			void^ ok -> {
				c:CustomPureFnGetter fn_getter = ok;
				CustomFnHandle fn_handle = fn_getter();

				FxArgs base_args = {
					.pos = e#pos,
					.scale = e#scale,
					.rotation = e#rotation,
					.color = e#color,
				};

				if (fn_handle.custom_arg_t_name != NULL) {
					c:CustomPureFnWithCustomParams fn = fn_handle.ptr;

					if (custom_args_handle is None) {
						let fx_new_fn_name = t"__scriptgen_NewFxArgs_{fn_handle.custom_arg_t_name}";
						let fn_args_new_res = code_man.GetFn(fx_new_fn_name); // creates handle
						switch (fn_args_new_res) {
							void^ ok -> {
								c:CustomArgsNewFn args_new_fn = ok;
								CustomStructHandle the_struct_handle = args_new_fn();
								println(t"called {fx_new_fn_name}");

								custom_float_layers = .();
								for (let& member in the_struct_handle.members) {
									custom_float_layers.add({
										.name = member.name,
										.deleted_member = false,
										.kind = match (member.t) {
											CustomStructMemberTypeFloat -> CustomLayerFloat{
												.value = member.ptr,
												.kl_value = .(),
											},
											CustomStructMemberTypeList -> CustomLayerList{
												.layers = .(),
												.fs = (member.t as CustomStructMemberTypeList).fs
											}
										}
									});
								}
								custom_args_handle = the_struct_handle;
							},
							char^ err -> {
								e#err_msg = t"failed to create new custom args `{fn_handle.custom_arg_t_name}`";
								return;
							}
						}
					}

					switch (custom_args_handle) {
						CustomStructHandle args_handle -> {
							fn(^base_args, args_handle.ptr);
						},
						None -> {
							e#err_msg = "[INTERNAL-ERROR]: custom_args_handle is None";
						}
					}
				} else {
					c:CustomPureFnWithoutCustomParams fn = fn_handle.ptr;
					custom_args_handle = none;

					fn(^base_args);
				}
				e#err_msg = NULL;
			},
			char^ err -> {
				e#err_msg = t"Failed to load effect `{fn_name}`. Make sure it exists and is correctly named in script.rpp and is marked @fx_fn! Error: {err}";
			}
		}
	}
	char^ ImplTypeStr() -> "fx";

	static Self^ Make(char^ fn_name) -> Box<Self>.Make({
		:fn_name,
		.custom_float_layers = .(),
		.custom_args_handle = none
	});

	List<CustomLayer>^ CustomLayers() {
		return ^custom_float_layers;
	}
}

// layer metadata
// (elements are stored separately)
struct Layer {
	bool visible;
}

struct Element {
	static int num_elements_created = 0; // TODO: make per-project!
	static char^ NextElementName() -> f"Elem {Self.num_elements_created++}";

	ElementImpl^ content_impl;

	char^ name;

	// temporal
	float start_time; // inclusive
	float duration;   // exclusive: i.e. at `start_time+duration`, this has just stopped playing
	// ^ TODO: maybe use `int` as frame-counts for these..?

	// layer
	int layer;
	
	// transform-related/common args
	Vec2 pos;
	KeyframeLayer kl_pos_x;
	KeyframeLayer kl_pos_y;

	Vec2 scale;
	KeyframeLayer kl_scale;
	bool uniform_scale; // TODO:

	float rotation;
	KeyframeLayer kl_rotation;

	float opacity;
	KeyframeLayer kl_opacity;

	Color color;

	bool visible;
	char^ err_msg;
	
	Data^ data;

	// name: pass NULL for auto-generated name
	construct(ElementImpl^ content_impl, char^ name, float start_time, float duration, int layer, Vec2 pos, Vec2 scale) -> {
		:content_impl,
		.name = (name != NULL) ? name | Element.NextElementName(),
		:pos,
		:scale,
		.uniform_scale = true,
		.rotation = 0,
		.opacity = 1,
		.color = c:GREEN,
		.kl_pos_x = .(),
		.kl_pos_y = .(),
		.kl_rotation = .(),
		.kl_opacity = .(),
		.kl_scale = .(),
		.visible = true,
		.data = NULL,
		.err_msg = NULL,
		:start_time,
		:duration,
		:layer,
	};

	// TODO: make sure that inclusion/exclusion is done right here
	bool CollidesWith(float other_start_time, float other_duration) -> end_time() > other_start_time && (other_start_time + other_duration) > start_time;

	// TODO: content type: rectangle, ellipse, image, text, etc
	// IDEA: text -> keyframe the text, morph between

	float end_time() -> start_time + duration;
	// bool IsVisibleAtTime(float time) -> visible && (time >= start_time && end_time() > time);
	bool ActiveAtTime(float time) -> time >= start_time && end_time() > time;

	bool Hovered() {
		// TODO:(worldspace)
		return mp_world_space.Between(pos, pos + scale);
	}

	void DrawGizmos() {
		let gizmoColor = Color{.r=255,.g=0,.b=255,.a=50};
		// d.RectRot(pos, scale, rotation, gizmoColor);
		d.RectOutline(pos, scale, hex("00000088"));
		d.Circle(pos + scale * v2(0.5, 0.5), 10, hex("9999FF55"));
	}

	void Draw() {
		content_impl#Draw(^this);
		// d.RectRot(pos, scale, rotation, color);
	}

	void UpdateState(float t) {
		float lt = t - start_time;
		kl_pos_x.SetFloat(^pos.x, lt);
		kl_pos_y.SetFloat(^pos.y, lt);

		kl_scale.SetFloat(^scale.x, lt);
		kl_scale.SetFloat(^scale.y, lt);

		kl_rotation.SetFloat(^rotation, lt);
		kl_opacity.SetFloat(^opacity, lt);

		// TODO: color

		if (content_impl#CustomLayers() != NULL) {
			for (let& layer in *content_impl#CustomLayers()) {
				layer.UpdateState(lt);
			}
		}

		// println(t"{pos.x} {pos.y} {scale.x} {scale.y} {kl_pos_x.HasValue()} a");
		// pos = v2(300, 200) * v2(t, t);
		// scale = v2(100, 100) * v2(1.0 + t, t * 2);
	}

	void ClearTimelinesCompletely() {
		kl_pos_x.Clear();
		kl_pos_y.Clear();
		kl_scale.Clear();
		kl_rotation.Clear();
		kl_opacity.Clear();
	}

	void ApplyData(Data^ data) {
		this.data = data;
	}

	// Apply keyframe data to an element's keyframes
    void ApplyKeyframeData(Data data, float start_time = 0.0, float frame_offset = 0.1) {

        let frame_time = start_time;
        for (let& row in data.data) {
            let keyframe_t = frame_time;
            frame_time = frame_time + frame_offset;
            if (ListContainsString(data.headers, "X")) {
                keyframe_t = row.get_float(t"Time");
            }

            if (ListContainsString(data.headers, "X")) {
                kl_pos_x.Insert({
                    .time = keyframe_t,
                    .value = row.get_float(t"X")
                });
            }
            if (ListContainsString(data.headers, "Y")) {
                kl_pos_y.Insert({
                    .time = keyframe_t,
                    .value = row.get_float(t"Y")
                });
            }
            if (ListContainsString(data.headers, "Opacity")) {
                kl_opacity.Insert({
                    .time = keyframe_t,
                    .value = row.get_float(t"Opacity")
                });
            }
            if (ListContainsString(data.headers, "Rotation")) {
                kl_rotation.Insert({
                    .time = keyframe_t,
                    .value = row.get_float(t"Rotation")
                });
            }
            if (ListContainsString(data.headers, "Scale")) {

                kl_scale.Insert({
                    .time = keyframe_t,
                    .value = row.get_float(t"Scale")
                });
            }
        }
    }
}

// KeyframeLayer make_interesting_layer_x() {
// 	KeyframeLayer layer = .();
// 	for (int i = 0; i != 6 * 4; i++;) {
// 		layer.keyframes.add({
// 			.time = i as float / 4,
// 			.value = 600 + ((i % 2 == 0) ? 1 | -1) * 200
// 		});
// 	}
// 	return layer;
// }
//
// KeyframeLayer make_interesting_layer_y() {
// 	KeyframeLayer layer = .();
// 	for (int i = 0; i != 36; i++;) {
// 		layer.keyframes.add({
// 			.time = i as float / 6,
// 			.value = Sin01(0.5 * i) * 600
// 		});
// 	}
// 	return layer;
// }
//
// KeyframeLayer make_rotation() {
// 	KeyframeLayer layer = .();
// 	layer.keyframes.add({
// 		.time = 0,
// 		.value = 0
// 	});
// 	layer.keyframes.add({
// 		.time = 5,
// 		.value = 360
// 	});
// 	return layer;
// }
//
// KeyframeLayer make_cool_layer_x() {
// 	KeyframeLayer layer = .();
// 	for (int i = 0; i != 3 * 4; i++;) {
// 		layer.keyframes.add({
// 			.time = i as float / 4 * 2.0,
// 			.value = 600 + ((i % 2 == 0) ? 1 | -1) * 200
// 		});
// 	}
// 	return layer;
// }
//
// KeyframeLayer make_cool_layer_y() {
// 	KeyframeLayer layer = .();
// 	for (int i = 0; i != 18; i++;) {
// 		layer.keyframes.add({
// 			.time = i as float / 3,
// 			.value = Sin01(0.5 * i) * 600
// 		});
// 	}
// 	return layer;
// }
//
// Element make_cool_fn_element() -> {
// 	.content_impl = CustomPureFnElement.new("cool_effect"),
// 	.name = "cool_fn",
// 	.pos = v2(0, 0),
// 	.scale = v2(20, 20),
// 	.uniform_scale = true,
// 	.rotation = 0,
// 	.opacity = 1,
// 	.color = Colors.Orange,
// 	.kl_pos_x = make_cool_layer_x(),
// 	.kl_pos_y = make_cool_layer_y(),
// 	.kl_rotation = make_rotation(),
// 	.kl_opacity = .(),
// 	.kl_scale = .(),
// 	.visible = false,
// 	.err_msg = NULL
// };
//
// Element make_custom_effect_element(char^ effect_name) -> {
// 	.content_impl = CustomPureFnElement.new(effect_name),
// 	.name = effect_name,
// 	.pos = v2(400, 400),
// 	.scale = v2(150, 150),
// 	.uniform_scale = true,
// 	.rotation = 0,
// 	.opacity = 1,
// 	.color = Colors.Green,
// 	.kl_pos_x = .(),
// 	.kl_pos_y = .(),
// 	.kl_rotation = .(),
// 	.kl_opacity = .(),
// 	.kl_scale = .(),
// 	.visible = true,
// 	.err_msg = NULL
// };
//
// Element make_perlin_element() {
// 	let it = make_custom_effect_element("perlin_field");
//
// 	it.kl_pos_x.Insert({
// 		.time = 0,
// 		.value = 0,
// 	});
// 	it.kl_pos_y.Insert({
// 		.time = 0,
// 		.value = 200,
// 	});
//
// 	it.kl_pos_x.Insert({
// 		.time = 2.5,
// 		.value = 500,
// 	});
// 	it.kl_pos_y.Insert({
// 		.time = 2.5,
// 		.value = 400,
// 	});
//
// 	it.kl_pos_x.Insert({
// 		.time = 5,
// 		.value = 1000,
// 	});
// 	it.kl_pos_y.Insert({
// 		.time = 5,
// 		.value = 200,
// 	});
//
// 	return it;
// }
//
// Element make_interesting_element() -> {
// 	.content_impl = make_rect(),
// 	.name = Element.NextElementName(),
// 	.pos = v2(0, 0),
// 	.scale = v2(200, 200),
// 	.uniform_scale = true,
// 	.rotation = 0,
// 	.opacity = 1,
// 	.color = c:BLUE,
// 	.kl_pos_x = make_interesting_layer_x(),
// 	.kl_pos_y = make_interesting_layer_y(),
// 	.kl_rotation = make_rotation(),
// 	.kl_opacity = .(),
// 	.kl_scale = .(),
// 	.visible = false,
// 	.err_msg = NULL
// };
//
// Element make_element() -> {
// 	.content_impl = make_circle(),
// 	.name = Element.NextElementName(),
// 	.pos = v2(400, 400),
// 	.scale = v2(150, 150),
// 	.uniform_scale = true,
// 	.rotation = 0,
// 	.opacity = 1,
// 	.color = c:GREEN,
// 	.kl_pos_x = .(),
// 	.kl_pos_y = .(),
// 	.kl_rotation = .(),
// 	.kl_opacity = .(),
// 	.kl_scale = .(),
// 	.visible = true,
// 	.err_msg = NULL
// };
//
// Element make_image_element(char^ file_path) -> {
// 	.content_impl = make_image(file_path),
// 	.name = Element.NextElementName(),
// 	.pos = v2(400, 400),
// 	.scale = v2(150, 150),
// 	.uniform_scale = true,
// 	.rotation = 0,
// 	.opacity = 1,
// 	.color = c:GREEN,
// 	.kl_pos_x = .(),
// 	.kl_pos_y = .(),
// 	.kl_rotation = .(),
// 	.kl_opacity = .(),
// 	.kl_scale = .(),
// 	.visible = true,
// 	.err_msg = NULL
// };
