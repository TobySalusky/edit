import rl;
import keyframing;
import maths;
import theming;
import std;
import code_manager;

interface ElementImpl {
	void Draw(Element^ e);
}
struct RectElement : ElementImpl {
	void Draw(Element^ e) {
		d.RectRot(e#pos, e#scale, e#rotation, e#color);
	}
}
RectElement^ make_rect() -> malloc(sizeof<RectElement>);

struct CircleElement : ElementImpl {
	void Draw(Element^ e) {
		d.Circle(e#pos + e#scale.scale(0.5), e#scale.x / 2, e#color); // TODO: allow ellipse
	}
}
CircleElement^ make_circle() -> malloc(sizeof<CircleElement>);

struct ImageElement : ElementImpl {
	char^ file_path;
	
	void Draw(Element^ e) {
		d.TextureAtSize(ImageCache.Get(file_path), e#pos.x, e#pos.y, e#scale.x, e#scale.y);
	}
}

ImageElement^ make_image(char^ file_path) {
	ImageElement^ it = malloc(sizeof<ImageElement>);
	it#file_path = file_path;
	return it;
}

c:`typedef void(*CustomPureFn)(Vec2, Vec2, float, Color);`;

struct ImageCache {
	static StrMap<Texture> cache;

	static Texture Get(char^ file_path) {
		if (Self.cache.has(file_path)) {
			return Self.cache.get(file_path);
		}
		Texture tex = LoadTextureFromFile(file_path);
		Self.cache.put(file_path, tex);
		return tex;
	}
	
	static void Unload() {
		for (let pair in Self.cache) {
			pair.value.delete();
		}
	}
}

struct CustomPureFnElement : ElementImpl {
	char^ fn_name;

	void Draw(Element^ e) {
		let fn_res = code_man.GetFn(fn_name);
		switch (fn_res) {
			void^ ok -> {
				c:CustomPureFn fn = ok;
				fn(e#pos, e#scale, e#rotation, e#color);
				e#err_msg = NULL;
			},
			char^ err -> {
				e#err_msg = t"Failed to load effect `{fn_name}`. Make sure it exists and is correctly named in script.rpp! Error: {err}";
			}
		}
	}

	static Self^ new(char^ fn_name) -> Box<Self>.Make({ :fn_name });
}

struct Element {
	static int num_elements_created = 0; // TODO: make per-project!
	static char^ NextElementName() -> f"Elem {Self.num_elements_created++}";

	ElementImpl^ content_impl;

	char^ name;
	
	Vec2 pos;
	KeyframeLayer kl_pos_x;
	KeyframeLayer kl_pos_y;

	Vec2 scale;
	KeyframeLayer kl_scale;
	bool uniform_scale; // TODO:

	float rotation;
	KeyframeLayer kl_rotation;

	float opacity;
	KeyframeLayer kl_opacity;

	Color color;

	bool visible;
	char^ err_msg;

	// TODO: content type: rectangle, ellipse, image, text, etc
	// IDEA: text -> keyframe the text, morph between


	bool Hovered() {
		return mouse.GetPos().Between(pos, pos + scale);
	}

	void DrawGizmos() {
		let gizmoColor = Color{.r=255,.g=0,.b=255,.a=50};
		// d.RectRot(pos, scale, rotation, gizmoColor);
		d.RectOutline(pos, scale, hex("00000088"));
		d.Circle(pos + scale * v2(0.5, 0.5), 10, hex("9999FF55"));
	}

	void Draw() {
		content_impl#Draw(^this);
		// d.RectRot(pos, scale, rotation, color);
	}

	void UpdateState(float t) {
		kl_pos_x.SetFloat(^pos.x, t);
		kl_pos_y.SetFloat(^pos.y, t);

		kl_scale.SetFloat(^scale.x, t);
		kl_scale.SetFloat(^scale.y, t);

		kl_rotation.SetFloat(^rotation, t);
		kl_opacity.SetFloat(^opacity, t);

		// println(t"{pos.x} {pos.y} {scale.x} {scale.y} {kl_pos_x.HasValue()} a");
		// pos = v2(300, 200) * v2(t, t);
		// scale = v2(100, 100) * v2(1.0 + t, t * 2);
	}

	void ClearTimelinesCompletely() {
		kl_pos_x.Clear();
		kl_pos_y.Clear();
		kl_scale.Clear();
		kl_rotation.Clear();
		kl_opacity.Clear();
	}
}

KeyframeLayer make_interesting_layer_x() {
	KeyframeLayer layer = .();
	for (int i = 0; i != 6 * 4; i++;) {
		layer.keyframes.add({
			.time = i as float / 4,
			.value = 600 + ((i % 2 == 0) ? 1 | -1) * 200
		});
	}
	return layer;
}

KeyframeLayer make_interesting_layer_y() {
	KeyframeLayer layer = .();
	for (int i = 0; i != 36; i++;) {
		layer.keyframes.add({
			.time = i as float / 6,
			.value = Sin01(0.5 * i) * 600
		});
	}
	return layer;
}

KeyframeLayer make_rotation() {
	KeyframeLayer layer = .();
	layer.keyframes.add({
		.time = 0,
		.value = 0
	});
	layer.keyframes.add({
		.time = 5,
		.value = 360
	});
	return layer;
}

KeyframeLayer make_cool_layer_x() {
	KeyframeLayer layer = .();
	for (int i = 0; i != 3 * 4; i++;) {
		layer.keyframes.add({
			.time = i as float / 4 * 2.0,
			.value = 600 + ((i % 2 == 0) ? 1 | -1) * 200
		});
	}
	return layer;
}

KeyframeLayer make_cool_layer_y() {
	KeyframeLayer layer = .();
	for (int i = 0; i != 18; i++;) {
		layer.keyframes.add({
			.time = i as float / 3,
			.value = Sin01(0.5 * i) * 600
		});
	}
	return layer;
}

Element make_cool_fn_element() -> {
	.content_impl = CustomPureFnElement.new("cool_effect"),
	.name = "cool_fn",
	.pos = v2(0, 0),
	.scale = v2(20, 20),
	.uniform_scale = true,
	.rotation = 0,
	.opacity = 1,
	.color = Colors.Orange,
	.kl_pos_x = make_cool_layer_x(),
	.kl_pos_y = make_cool_layer_y(),
	.kl_rotation = make_rotation(),
	.kl_opacity = .(),
	.kl_scale = .(),
	.visible = false,
	.err_msg = NULL
};

Element make_custom_effect_element(char^ effect_name) -> {
	.content_impl = CustomPureFnElement.new(effect_name),
	.name = effect_name,
	.pos = v2(400, 400),
	.scale = v2(150, 150),
	.uniform_scale = true,
	.rotation = 0,
	.opacity = 1,
	.color = c:GREEN,
	.kl_pos_x = .(),
	.kl_pos_y = .(),
	.kl_rotation = .(),
	.kl_opacity = .(),
	.kl_scale = .(),
	.visible = true,
	.err_msg = NULL
};

Element make_perlin_element() {
	let it = make_custom_effect_element("perlin_field");

	it.kl_pos_x.Insert({
		.time = 0,
		.value = 0,
	});
	it.kl_pos_y.Insert({
		.time = 0,
		.value = 200,
	});

	it.kl_pos_x.Insert({
		.time = 2.5,
		.value = 500,
	});
	it.kl_pos_y.Insert({
		.time = 2.5,
		.value = 400,
	});

	it.kl_pos_x.Insert({
		.time = 5,
		.value = 1000,
	});
	it.kl_pos_y.Insert({
		.time = 5,
		.value = 200,
	});

	return it;
}

Element make_interesting_element() -> {
	.content_impl = make_rect(),
	.name = Element.NextElementName(),
	.pos = v2(0, 0),
	.scale = v2(200, 200),
	.uniform_scale = true,
	.rotation = 0,
	.opacity = 1,
	.color = c:BLUE,
	.kl_pos_x = make_interesting_layer_x(),
	.kl_pos_y = make_interesting_layer_y(),
	.kl_rotation = make_rotation(),
	.kl_opacity = .(),
	.kl_scale = .(),
	.visible = false,
	.err_msg = NULL
};

Element make_element() -> {
	.content_impl = make_circle(),
	.name = Element.NextElementName(),
	.pos = v2(400, 400),
	.scale = v2(150, 150),
	.uniform_scale = true,
	.rotation = 0,
	.opacity = 1,
	.color = c:GREEN,
	.kl_pos_x = .(),
	.kl_pos_y = .(),
	.kl_rotation = .(),
	.kl_opacity = .(),
	.kl_scale = .(),
	.visible = true,
	.err_msg = NULL
};

Element make_image_element(char^ file_path) -> {
	.content_impl = make_image(file_path),
	.name = Element.NextElementName(),
	.pos = v2(400, 400),
	.scale = v2(150, 150),
	.uniform_scale = true,
	.rotation = 0,
	.opacity = 1,
	.color = c:GREEN,
	.kl_pos_x = .(),
	.kl_pos_y = .(),
	.kl_rotation = .(),
	.kl_opacity = .(),
	.kl_scale = .(),
	.visible = true,
	.err_msg = NULL
};
