import std;
import map;

import dylib;

c:`typedef void(*CustomScriptSetupFn)(void);`;

struct CodeManager {
	Path dylib_path;
	Path old_dylib_path;
	Path new_dylib_path;

	Opt<DyLib> code_handle;
	StrMap<void^> fn_handles;

	construct(char^ result_dir) {
		Path dir = .(result_dir);
		return {
			.dylib_path =     dir/t"libscript.{DYNAMIC_LIB_EXTENSION}",
			.old_dylib_path = dir/t"oldlibscript.{DYNAMIC_LIB_EXTENSION}",
			.new_dylib_path = dir/t"newlibscript.{DYNAMIC_LIB_EXTENSION}",

			.code_handle = none,
			.fn_handles = .(),
		};
	}

	void Load() {
		code_handle = DyLib.LoadOrPanic(dylib_path);

		// reload function pointers!
		for (int i in 0..fn_handles.size) {
			let fn_name = fn_handles.keys[i];
			fn_handles.values[i] = this.Lib().SymOrPanic(fn_name);
		}

		c:CustomScriptSetupFn setup_fn = this.GetFn("script_setup"); 
		setup_fn();
	}

	void CheckModifiedTimeAndReloadIfNecessary() {
		if (!io.file_exists(new_dylib_path)) { return; }

		this.Lib().Unload();

		io.rm_if_existent(old_dylib_path);
		io.mv(dylib_path, old_dylib_path);
		io.mv(new_dylib_path, dylib_path);
		
		this.Load();
	}

	DyLib& Lib() {
		switch (code_handle) {
			DyLib lib -> { DyLib^ l = ^lib; return *l; },
			else -> panic("Lib() failed - not loaded!"),
		}
		// unreachable
		DyLib^ blah = NULL;
		return *blah;
	}

	// void Reload() {
	// 	this.Lib().Unload();
	// 	this.Load();
	// }
	//
	void Unload() {
		this.Lib().Unload();
		code_handle = none;
		fn_handles.delete();
	}

	void^ GetFn(char^ fn_name) {
		if (fn_handles.has(fn_name)) {
			return fn_handles.get(fn_name);
		}

		void^ ptr = this.Lib().SymOrPanic(fn_name);
		fn_handles.put(fn_name, ptr);

		return ptr;
	}
}

// NOTE: assumes program is run from git repo root (`edit/`)
CodeManager code_man = .("test_resource");
