import theming;
import rl;
import std;

struct KeyframeInterpolator {
	
}
struct KeyframeInterpolator=<float> {
	static float Interpolate(float from, float to, float t) {
		return from * (1.0 - t) + to * t;
	}
}

struct Keyframe<T> {
	T value;
	float time;
}

struct KeyframeLayer<T> {
	List<Keyframe<T>> keyframes;
	// bool activated;

	construct() -> { .keyframes = List<Keyframe<T>>() };

	bool HasValue() {
		return 
		// activated && 
		keyframes.size > 0;
	}

	Keyframe<T> BestFrom(float time) {
		Keyframe<T> best = keyframes.get(0);
		for (let keyframe in keyframes) {
			if (keyframe.time <= time) {
				best = keyframe;
			}
		}
		return best;
	}

	Keyframe<T> BestTo(float time) {
		for (let keyframe in keyframes) {
			if (keyframe.time > time) {
				return keyframe;
			}
		}
		return keyframes.get(keyframes.size - 1);
	}

	T GetValue(float time) {
		if (!this.HasValue()) { panic("No value! [GetValue]"); }

		Keyframe<T> from = this.BestFrom(time);
		Keyframe<T> to = this.BestTo(time);

		// TODO: skip interpolation when before/after first/last

		float t_range = to.time - from.time;
		if (t_range == 0) { t_range = 1; } // TODO: almost equal to zero?

		float t = (time - from.time) / t_range;
		float it = 1.0 - t;

		return KeyframeInterpolator<T>.Interpolate(from.value, to.value, t);
	}

	void Set(T^ setter, float time) {
		if (!this.HasValue()) { return; }

		*setter = this.GetValue(time);
	}

	void UI(Vec2 global_tl, Vec2 dimens, float max_elem_time, float curr_local_time, char^ name, int& incr) {
		int i = incr;
		let tl = global_tl + v2(0, dimens.y * i);

		d.Text(name, (tl.x - 90) as.., tl.y as.., 16, Colors.White);
		d.Rect(tl + v2(0, dimens.y), v2(dimens.x, 1), theme.panel_border);

		if (mouse.GetPos().Between(tl - v2(90, 0), tl + v2(0, dimens.y)) && mouse.LeftClickPressed()) {
			Vec2 _dims = (tl + v2(0, dimens.y)) - (tl - v2(90, 0));
			Vec2 delta = mouse.GetPos() - (tl - v2(90, 0));
			float value = (delta.x / _dims.x) * 300;

			println(t"setting value to: {value} {(tl - v2(90, 0)).x} {(tl - v2(90, 0)).y} {(tl + v2(0, dimens.y)).x} {(tl + v2(0, dimens.y)).y}");
			println(t"name of layer being set is: {name}");

			Insert({
				:value,
				.time = curr_local_time
			});
		}

		Vec2 from = tl + v2(0, dimens.y / 2);
		Vec2 to = from + v2(dimens.x, 0);
		for (int i = 0; i != keyframes.size; i++;) {
			let keyframe = keyframes.get(i);
			float t = keyframe.time / max_elem_time;
			float it = 1.0 - t;

			Vec2 circle_v = from * v2(it, it) + to * v2(t, t);
			d.Circle(circle_v, 0.2 * dimens.y, hex("FFFFFFAA"));

			d.TextTemp(t"{i}", circle_v);
		}
	}

	void Insert(Keyframe<T> frame) {
		for (int i = 0; i != keyframes.size; i++;) {
			if (frame.time == keyframes.get(i).time) {
				keyframes.get(i) = frame;
				return;
			}
		}

		int best = keyframes.size;
		for (int i = 0; i != keyframes.size; i++;) {
			if (frame.time < keyframes.get(i).time) {
				best = i;
				break;
			}
		}
		keyframes.add_at(frame, best);
	}

	void Clear() {
		keyframes.delete();
		keyframes = List<Keyframe<T>>();
	}
}
